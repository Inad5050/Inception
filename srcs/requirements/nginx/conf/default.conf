# listen 443 ssl
#	443 es el puerto estandard para peticiones HTTPS
#	ssl le dice que acepte unicamente conexiones cifradas
#	SSL (SecureSocketsLayer) es un protocolo criptográfico, el predecesor de TLS (TransportLayerSecurity)
#	TLS es el standard actual para la mayoría de las aplicaciones de internet
#	usamos TLS, pero en las directivas se sigue poniendo SSL por motivos historicos
# index index.php;
#	se asume que Wordpress incluye el archivo index.php (NGINX no incluye archivos de aplicaciones)
#	Wordpres montará index.php en el root de NGINX
# configuración de la conexión cifrada HTTPS:
#	- ssl_certificate: ruta al certificado público (.crt)
#	el servidor se lo envía al navegador para verificar su identidad
#	- ssl_certificate_key: ruta a la clave privada (.key)
#	el servidor la usa para verificar la respuesta del navegador
#	- ssl_protocols: especifica que versión de TLS se usara. Se desactivan versiones más antiguas
# "try_files $uri $uri/ /index.php?$args;" NGINX intentara en orden:
#	1. $uri buscar un archivo con el nombre exacto de la petición (/logo.png)
#	2. $uri/ buscar un directorio con ese nombre
#	3. la petición se pasa a php. &args es la query string del URL original (los valores del URL tras '?')
#	en este contexto $ se usa para indicar que lo que sigue es una variable interna de NGINX
#	la uri (UniformResourceIndentifier) es la parte del URL después del dominio
# "location ~ \.php$" captura cualquier petición que acabe en php
#	~ le indica a NGINX que distinga entre mayúsculas y minúsculas ("/index.PHP" no entraría en esta location)
#	\ escapa el punto, para que sea un caracter literal, sin esto '.' significaria "cualquier caracter"
#	$ indica el final de la cadena, de forma que /index.php/test no entraría en esta location por tener "/test"
#	NGINX no procesa peticiones php, se la pasa a Wordpress, que posee el servicio PHP-FPM, escuchando en el puerto 9000
#	- PHP: HypertextPreprocessor
#	- FPM: FastCGI Process Manager. Al contrario que CGI que inicia y destruye un proceso por cada petición,
#	fastCGI matiene los procesos de a aplicación activos en segundo plano
# "include fastcgi_params;" carga el archivo fastcgi_params, que incluye 
# "fastcgi_pass wordpress:9000" NGINX no puede procesar php, se lo pasa a un tercero
#	le dice a NGINX que redirecione la petición al servicio wordpress (el contendor de WordPress) en el puerto 9000

server
{
    listen 443 ssl;
    server_name dangonz3.42.fr;

    root /var/www/html;
    index index.php;

    ssl_certificate         /etc/ssl/certs/nginx-selfsigned.crt;
    ssl_certificate_key     /etc/ssl/private/nginx-selfsigned.key;
    ssl_protocols           TLSv1.3;

    location / 
	{
        try_files $uri $uri/ /index.php?$args;
    }

    location ~ \.php$ 
	{
        include fastcgi_params;
        fastcgi_pass wordpress:9000;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
    }
}

# --- NOTAS ---

# TLS Handshake
# Objective: to authenticate the server to the client and to have both parties securely negotiate a 
# shared secret (session key) for encrypting subsequent communication.
# 1. Client Hello: the client sends a message to the server:
#	- The TLS protocol versions the client supports.
#	- A list of cryptographic algorithms (cipher suites) the client can use. Cipher suite: un conjunto de algoritmos 
#	que definen los parámetros criptográficos para una conexión TLS.
#	- A random string of bytes, known as the Client Random.
# 2. Server Hello and Certificate Exchange:
#	- Server Hello: confirms the chosen protocol version and cipher suite from the list provided by the client. 
#	- The server generates and sends its own Server Random value.
#	- Certificate Exchange: The server sends its SSL/TLS Certificate. This certificate contains the server's public key 
#	and identity information, which has been digitally signed by a trusted Certificate Authority (CA).
# 3. Certificate Verification and Key Exchange:
#	- Certificate Validation: The client verifies the server's certificate against its list of trusted CAs.
#	- Key Generation: The client generates another random value, the premaster secret.
#	- Asymmetric Encryption: The client encrypts the premaster secret using the server's public key. 
#	- It then sends this encrypted value to the server, only the holder of the corresponding private key can decrypt this message. 
#	By successfully decrypting the premaster secret, the server proves it possesses the private key and is therefore legitimate.
# 4. Session Key Generation and Encrypted Session
#	Both have the same three pieces of information: the Client Random, the Server Random, and the premaster secret. 
#	Both parties independently use these values to derive an identical set of symmetric session keys.
#	From this point forward, all application data between the client and server is encrypted and decrypted using these symmetric keys.
